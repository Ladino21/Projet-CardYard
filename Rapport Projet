Rapport de Projet – Card Yard
Équipe et sujet
Projet réalisé par Nidal (main.c, jeu.c, affichage.c), Adam (cartes.c, save.c, joueurs.c), et Younes (classement des scores dans affichage.c).
Card Yard est un jeu de cartes multijoueur (2 à 8 joueurs) où chacun tente d’obtenir le plus petit score. Les cartes peuvent être cachées, visibles ou retournées. Le jeu propose des variantes (pioche par défaut ou fichier, nombre variable de cartes, fin de partie dynamique), un affichage coloré et un système complet de sauvegarde/chargement.

Organisation du travail
Dès le départ, nous avons séparé les tâches par fichiers. Chacun s’est concentré sur ses modules, avec une communication régulière pour assurer la cohérence. Tous les fichiers .c sont accompagnés de leur .h, avec des noms clairs et en français pour une bonne lisibilité.

Problèmes rencontrés et solutions
1. Pointeurs et structures :
La gestion de plusieurs tableaux dynamiques (pioche, défausse, cartes des joueurs) a été difficile au début. On s’est souvent perdus avec les malloc, les accès aux champs, ou les appels entre fonctions. On a beaucoup appris en corrigeant ces erreurs.

2. strcspn et chaînes :
Pour éviter des bugs lors de la lecture de fichiers (avec fgets), on a utilisé strcspn pour retirer les \n. Une petite fonction qu’on ne connaissait pas mais qui a rendu notre gestion des chaînes bien plus propre.

3. Fin de partie :
Au début, la partie s’arrêtait brutalement dès qu’un joueur retournait toutes ses cartes. On a ajusté la logique pour révéler toutes les cartes restantes et afficher un classement complet des scores.

4. Affichage coloré et lisible :
Rendre l’affichage agréable dans le terminal a été un vrai défi. On a utilisé les couleurs ANSI pour remplir entièrement les cartes selon leur valeur, et affiché les équipes côte à côte pour plus de clarté.

5. Mélange équitable :
On a utilisé l’algorithme de Fisher-Yates, rapide (O(n)), en place (sans tableau temporaire), et garantissant un vrai hasard. C’est un standard dans les jeux numériques.

6. Sauvegarde/Chargement :
On a choisi fwrite / fread pour stocker directement les structures en binaire. C’est plus simple, rapide et fiable qu’un format texte, tout en garantissant une restauration parfaite de l’état du jeu.

7. Gestion des pioches :
Même si la pioche peut être créée via un fichier (value_file), on a aussi prévu une pioche par défaut. Ce n’était pas obligatoire, mais essentiel pour que l’utilisateur puisse jouer même sans fichier externe.

Conclusion
Le jeu est stable, fluide, et propose une expérience complète avec :

Plusieurs joueurs

Sauvegarde/chargement

Affichage clair et coloré

Pioche fichier ou par défaut

Variantes dynamiques

Chacun a rempli sa mission, et le travail en équipe a été efficace.
Nous espérons que ce jeu vous plaira autant qu’il nous a passionnés à coder.
