Rapport de Projet â€“ Card Yard
Ã‰quipe et sujet
Projet rÃ©alisÃ© par Nidal (main.c, jeu.c, affichage.c), Adam (cartes.c, save.c, joueurs.c), et Younes (classement des scores dans affichage.c).
Card Yard est un jeu de cartes multijoueur (2 Ã  8 joueurs) inspirÃ© de Skyjo, oÃ¹ lâ€™objectif est dâ€™obtenir le plus petit score. Chaque joueur possÃ¨de des cartes cachÃ©es, visibles ou retournÃ©es, quâ€™il peut manipuler en piochant, Ã©changeant ou dÃ©faussant. Le jeu propose plusieurs variantes (pioche par fichier ou par dÃ©faut, nombre de cartes variable, fin de partie dynamique), un affichage colorÃ© dans le terminal, et un systÃ¨me complet de sauvegarde et chargement.

Organisation du travail
DÃ¨s le dÃ©but, nous avons rÃ©parti les fichiers par personne : Adam sâ€™est occupÃ© des cartes, joueurs et sauvegardes ; Nidal de la logique de jeu, de lâ€™affichage et du fichier principal ; Younes a aidÃ© Ã  rendre lâ€™affichage du classement clair et lisible.
Nous avons optÃ© pour un nommage en franÃ§ais, des fichiers bien sÃ©parÃ©s (.c et .h) et une logique modulaire pour que le code reste simple, lisible et maintenable.

ProblÃ¨mes rencontrÃ©s, choix techniques, limites et amÃ©liorations
1. Gestion complexe des pointeurs et structures
Lâ€™un des plus gros dÃ©fis a Ã©tÃ© de manipuler correctement les pointeurs, structures et tableaux dynamiques (pioche, dÃ©fausse, cartes des joueurs). On sâ€™est souvent perdus avec les malloc, les accÃ¨s aux champs, et les effets de bord entre fonctions. Cela nous a poussÃ©s Ã  structurer plus proprement le code et mieux documenter nos structures.
ğŸ’¡ Limite : le projet ne permet pas de gÃ©rer plusieurs sauvegardes distinctes, ce qui limite les possibilitÃ©s de reprise.

2. PropretÃ© des chaÃ®nes de caractÃ¨res (strcspn)
Pour Ã©viter les erreurs dues aux retours Ã  la ligne dans les fgets, on a utilisÃ© strcspn. Ce dÃ©tail a renforcÃ© la robustesse du chargement des pioches personnalisÃ©es.
âœ… Choix pertinent pour Ã©viter les bugs invisibles et simplifier le traitement des fichiers texte.

3. Fin de partie et affichage du classement
Initialement, la partie se terminait dÃ¨s quâ€™un joueur retournait toutes ses cartes, sans afficher le score des autres. On a ajustÃ© cela pour rÃ©vÃ©ler toutes les cartes restantes et afficher un classement gÃ©nÃ©ral. Younes a contribuÃ© Ã  rendre ce classement plus clair.
âš ï¸ Limite : si beaucoup de joueurs sont prÃ©sents, lâ€™affichage devient un peu dense, mais lisible grÃ¢ce Ã  notre mise en page horizontale.

4. Affichage colorÃ© et intuitif dans le terminal
Lâ€™affichage a Ã©tÃ© un vrai dÃ©fi. Nous avons utilisÃ© les codes ANSI pour colorer entiÃ¨rement les cartes selon leur valeur, ce qui rend le jeu plus visuel malgrÃ© les limites du terminal. Les cartes sont affichÃ©es horizontalement, cÃ´te Ã  cÃ´te, ce qui facilite la lecture.
ğŸ¯ Bonus : les cartes dÃ©jÃ  visibles ne peuvent plus Ãªtre Ã©changÃ©es. Ce choix volontaire rend les tours plus stratÃ©giques, car l'information n'est pas toujours exploitable.

5. MÃ©lange Ã©quitable avec lâ€™algorithme de Fisher-Yates
Pour mÃ©langer les cartes, nous avons choisi lâ€™algorithme de Fisher-Yates. Il est rapide (O(n)), fonctionne sans tableau temporaire, et donne Ã  chaque permutation la mÃªme probabilitÃ©. Câ€™est une mÃ©thode utilisÃ©e dans les jeux professionnels.
âœ… Choix technique majeur, garantissant lâ€™Ã©quitÃ© et la performance.

6. Sauvegarde et chargement binaire
Nous avons optÃ© pour fwrite et fread afin de stocker directement les structures en binaire. Cela Ã©vite les conversions texte complexes, amÃ©liore les performances et garantit une restauration fidÃ¨le de la partie.
ğŸ’¡ Limite : une seule sauvegarde possible par dÃ©faut, ce qui limite la reprise de diffÃ©rentes parties.

7. Double systÃ¨me de pioche
Le jeu propose deux maniÃ¨res de gÃ©nÃ©rer la pioche : soit automatiquement (pioche par dÃ©faut), soit Ã  partir dâ€™un fichier personnalisÃ© (value_file). MÃªme si cette seconde option nâ€™Ã©tait pas obligatoire, nous lâ€™avons ajoutÃ©e pour plus de flexibilitÃ©.
ğŸ² Bonus : cette double possibilitÃ© rend le jeu plus riche, car lâ€™utilisateur peut crÃ©er ses propres scÃ©narios ou jouer rapidement avec une pioche alÃ©atoire.

Conclusion
Ce projet nous a permis de progresser en C tout en travaillant efficacement en Ã©quipe. MalgrÃ© quelques limites (affichage dense, sauvegarde unique, cartes visibles non modifiables), Card Yard est un jeu stable, complet, et agrÃ©able Ã  jouer grÃ¢ce Ã  ses choix techniques simples mais solides.
Nous sommes satisfaits du rÃ©sultat et fiers du travail accompli ensemble.
